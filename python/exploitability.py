# Implementation of Local Best Response calculation for a lower bound on
# exploitability from https://arxiv.org/abs/1612.07547

# I'm using the "fcpa" (fold, call, pot, all-in) action choices from the paper, which is
# way faster and still gives decent results. I'm also having the exploiter
# check/call on the preflop and flop.

from itertools import combinations, product
import numpy as np
from tqdm import trange
from texas_utils import get_deck
from trainer_utils import normalize
from texas_hands import TexasHand
from hand_table import HandTable
from texas_utils import pbar_map
import spartacus


ITERS = 2000
ROLLOUT_SAMPLES = 50
BIG_BLIND = 100
STACK_SIZE = 200 * BIG_BLIND
ACTIONS = 'fold', 'call', 'pot', 'all-in'
FOLD = {'action': 'fold', 'amount': 0}
HAND_TABLE = HandTable()


def check_call(street, stacks):
    if street == "preflop" and sum(stacks.values()) == 2*STACK_SIZE:
        return {"action": "bet", "amount": BIG_BLIND}
    else:
        return {"action": "call", "amount": abs(stacks["opponent"] - stacks["exploiter"])}


def cpu_action(street, stacks):
    return random_action(stacks)


def rollouts(hole1, hole2, board, street):
    deck = get_deck()
    deck.remove(hole1[0])
    deck.remove(hole1[1])
    deck.remove(hole2[0])
    deck.remove(hole2[1])
    if street == 'preflop':
        n_rollouts = 5
    elif street == 'flop':
        n_rollouts = 2
    elif street == 'turn':
        n_rollouts = 1
    elif street == 'river':
        return [board]

    # Remove board cards already in deck
    n_board = 5 - n_rollouts
    for i in range(n_board):
        deck.remove(board[i])

    rollouts = [board[:n_board] + list(rollout) for rollout in combinations(deck, n_rollouts)]
    return rollouts


def win_probability(exploiter_hole, opp_range, board, street):
    win_prob = 0
    opp_hands = list(opp_range.keys())
    np.random.shuffle(opp_hands)
    # TODO: Sample hands proportionally to their range probability weight
    for opp_hole in opp_hands[:ROLLOUT_SAMPLES]:
        wins = 0
        n = 0
        for rollout in rollouts(exploiter_hole, list(opp_hole), board, street):
            exploiter_hand = exploiter_hole + rollout
            opp_hand = list(opp_hole) + rollout
            exploiter_strength = HAND_TABLE[exploiter_hand]
            opp_strength = HAND_TABLE[opp_hand]
            if exploiter_strength > opp_strength:
                wins += 1
            elif exploiter_strength == opp_strength:
                wins += 0.5
            n += 1

        # win_prob += opp_range[opp_hole] * wins/n
        win_prob += wins / n / ROLLOUT_SAMPLES

    return win_prob


def always_call(opp_hand, board, action):
    # Always call
    if action == 'call':
        return 1
    else:
        return 0


def random_action(stacks):
    return np.random.choice(opponent_actions(stacks))


def get_amount(action, pot, stacks):
    if action == 'pot':
        return pot
    elif action == 'all-in':
        return stacks["exploiter"]
    elif action == 'fold':
        return 0
    elif action == 'call':
        return abs(stacks["exploiter"] - stacks["opponent"])


def legal_bets(stacks):
    pot = 2*STACK_SIZE - stacks["exploiter"] - stacks["opponent"]
    if stacks["exploiter"] > pot:
        return ('pot', 'all-in')
    elif stacks['exploiter'] > 0:
        return ('all-in',)
    else:
        return ()


def opponent_actions(stacks):
    actions = []
    to_call = stacks['opponent'] - stacks['exploiter']
    if stacks['opponent'] + stacks['exploiter'] == 0:
        to_call = BIG_BLIND     # Need to put in at least a big blind on the preflop
    actions.append({'action': 'call', 'amount': to_call})
    if to_call > 0:     # Doesn't make sense to fold if you can check (call with 0)
        actions.append({'action': 'fold', 'amount': 0})
    min_bet = min(BIG_BLIND, to_call * 2)
    max_bet = stacks['opponent']
    if max_bet > min_bet:
        bet = np.random.randint(min_bet, max_bet)
        actions.append({'action': 'bet', 'amount': bet})

    return actions


def chump_strategy(stacks):
    # For the "random action" chump bot
    possible_actions = opponent_actions(stacks)
    if FOLD not in possible_actions:
        return 0
    else:
        return 1 / len(possible_actions)


def local_best_response(strategy, opp_range, history, board, exploiter_hole, street, stacks):
    if street == "preflop" or street == "flop":
        return check_call(street, stacks)

    utilities = {action: 0 for action in ACTIONS}
    new_range = opp_range.copy()
    win_prob = win_probability(exploiter_hole, opp_range, board, street)
    to_call = stacks["exploiter"] - stacks["opponent"]
    pot = 2*STACK_SIZE - stacks["exploiter"] - stacks["opponent"]
    utilities['call'] = win_prob * pot - (1 - win_prob) * to_call
    for action in legal_bets(stacks):
        fold_prob = 0
        for opp_hand in opp_range:
            opp_strategy = spartacus.get_strategy(stacks)
            fold_prob += opp_range[opp_hand] * opp_strategy
            new_range[opp_hand] = opp_range[opp_hand] * (1 - opp_strategy)

        normalize(new_range)
        win_prob = win_probability(exploiter_hole, new_range, board, street)
        amount = get_amount(action, pot, stacks)
        utilities[action] = fold_prob * pot + (1 - fold_prob) * (win_prob * (pot + amount) - (1 - win_prob) * (to_call + amount))

    if max(utilities.values()) > 0:
        action = max(utilities.keys(), key=lambda a: utilities[a])
        return {"action": action, "amount": get_amount(action, pot, stacks)}
    else:
        return {"action": "fold", "amount": 0}


def update_range(opp_range, strategy):
    return opp_range    # Since the opponent is always calling here, we get no new range information


def whose_turn(street, dealer):
    if street == "preflop":
        return dealer
    elif dealer == "exploiter":
        return "opponent"
    else:
        return "exploiter"


def remove_blockers(opp_range, board, street):
    if street == "preflop":
        n_blockers = 0
    elif street == "flop":
        n_blockers = 3
    elif street == "turn":
        n_blockers = 4
    elif street == "river":
        n_blockers = 5
    blockers = board[:n_blockers]
    new_range = opp_range.copy()
    for blocker in blockers:
        for hand in opp_range:
            if blocker in hand and hand in new_range:
                del new_range[hand]
    return new_range


def play_hand(strategy):
    deck = get_deck()
    np.random.shuffle(deck)
    exploiter_hole = deck[:2]
    opponent_hole = deck[2:4]
    board = deck[4:9]

    dealer = "exploiter"
    if np.random.random() > 0.5:
        dealer = "opponent"

    deck.remove(exploiter_hole[0])
    deck.remove(exploiter_hole[1])
    opp_range = {frozenset((card1, card2)): 1 for (card1, card2) in combinations(deck, 2)}
    normalize(opp_range)

    stacks = {"exploiter": STACK_SIZE, "opponent": STACK_SIZE}
    streets = 'preflop', 'flop', 'turn', 'river'
    history = {street: [] for street in streets}

    for street in 'preflop', 'flop', 'turn', 'river':
        turn = whose_turn(street, dealer)
        opp_range = remove_blockers(opp_range, board, street)
        while True:
            if turn == "exploiter":
                action = local_best_response(strategy, opp_range, history, board, exploiter_hole, street, stacks)
                stacks["exploiter"] -= action["amount"]
                turn = "opponent"
                if action["action"] == "fold":
                    return stacks["exploiter"] - STACK_SIZE
            else:
                action = spartacus.get_action(opponent_hole, board, history)
                opp_range = update_range(opp_range, strategy)
                stacks["opponent"] -= action["amount"]
                turn = "exploiter"
                if action["action"] == "fold":
                    return STACK_SIZE - stacks["opponent"]
            history[street].append(action)
            if len(history[street]) >= 2 and stacks["exploiter"] == stacks["opponent"]:
                break
        if stacks["exploiter"] + stacks["opponent"] == 0:
            break   # Break out if both players have already went all-in

    # Showdown
    exploiter_hand = TexasHand(exploiter_hole + board)
    opponent_hand = TexasHand(opponent_hole + board)
    half_pot = STACK_SIZE - stacks["exploiter"]
    if exploiter_hand > opponent_hand:
        return half_pot
    elif opponent_hand > exploiter_hand:
        return -half_pot
    else:
        return 0    # split pot


def plot(distribution):
    from matplotlib import pyplot as plt
    plt.figure()
    plt.hist(distribution, bins=50)
    plt.show()


def exploit(strategy):
    # Multiprocessed
    # exploitability = pbar_map(play_hand, [{} for i in range(ITERS)])
    # exploitability = np.array(exploitability) / BIG_BLIND

    # Single process
    exploitability = np.zeros(ITERS)
    for i in trange(ITERS):
        exploitability[i] = play_hand(strategy) / BIG_BLIND
        mean = np.mean(exploitability[:i])
        std = np.std(exploitability[:i])
        confidence = 1.96 * std / np.sqrt(i+1)
        print("{} +/- {} BB/h".format(mean, confidence))

    mean = np.mean(exploitability)
    std = np.std(exploitability)
    confidence = 1.96 * std / np.sqrt(ITERS)
    print("{} +/- {} BB/h".format(mean, confidence))
    plot(exploitability)


if __name__ == '__main__':
    strategy = {}
    exploit(strategy)
