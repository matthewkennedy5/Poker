// Implementation of Local Best Response calculation for a lower bound on
// exploitability from https://arxiv.org/abs/1612.07547

use crate::bot::Bot;
use crate::card_utils;
use crate::card_utils::*;
use crate::config::CONFIG;
use crate::ranges::*;
use crate::trainer_utils::*;
use crate::nodes::*;
use rand::seq::SliceRandom;
use rayon::iter::IntoParallelIterator;
use rayon::iter::ParallelIterator;
use smallvec::{SmallVec, ToSmallVec};
use std::collections::HashMap;

// const BETS: [f64; 5] = [0.25, 0.75, 1.0, 2.0, ALL_IN];
const BETS: [f64; 2] = [1.0, ALL_IN];

pub fn bot_exploitability(bot: &Bot, iters: u64) -> f64
 {
    println!("[INFO] Calculating exploitability...");
    let bar = card_utils::pbar(iters);

    let exploits: Vec<f64> = (0..iters)
        .into_par_iter()
        .map(|_i| {
            let get_strategy = |hole: &[Card], board: &[Card], history: &ActionHistory| {
                bot.get_strategy(hole, board, history)
            };
            let e = play_hand(&get_strategy) / (CONFIG.big_blind as f64);
            bar.inc(1);
            e
        })
        .collect();

    bar.finish();
    let mean = statistical::mean(&exploits);
    let std = statistical::standard_deviation(&exploits, Some(mean));
    let confidence = 1.96 * std / (iters as f64).sqrt();
    println!("Exploitability: {mean} +/- {confidence} BB/h\n");
    mean
}

pub fn blueprint_exploitability(blueprint: &Nodes, iters: u64) -> f64 {
    println!("[INFO] Calculating exploitability...");
    let bar = card_utils::pbar(iters);

    let exploits: Vec<f64> = (0..iters)
        .into_par_iter()
        .map(|_i| {
            let get_strategy = |hole: &[Card], board: &[Card], history: &ActionHistory| {
                blueprint.get_strategy(hole, board, history)
            };
            let e = play_hand(&get_strategy) / (CONFIG.big_blind as f64);
            bar.inc(1);
            e
        })
        .collect();

    bar.finish();
    let mean = statistical::mean(&exploits);
    let std = statistical::standard_deviation(&exploits, Some(mean));
    let confidence = 1.96 * std / (iters as f64).sqrt();
    println!("Exploitability: {mean} +/- {confidence} BB/h\n");
    mean
}

fn play_hand<F>(get_strategy: &F) -> f64 
where F: Fn(&[Card], &[Card], &ActionHistory) -> Strategy
{
    let mut deck = card_utils::deck();
    let mut rng = &mut rand::thread_rng();
    deck.shuffle(&mut rng);
    let exploiter = *[DEALER, OPPONENT].choose(&mut rng).unwrap();
    let opponent = 1 - exploiter;
    let mut opp_range: Range = Range::new();
    let exploiter_hole = get_hand(&deck, exploiter, PREFLOP);
    opp_range.remove_blockers(&exploiter_hole);

    let mut history = ActionHistory::new();

    while !history.hand_over() {
        let blockers = get_hand(&deck, exploiter, history.street);
        opp_range.remove_blockers(&blockers);
        let action = if history.player == exploiter {
            let range = opp_range.clone();
            local_best_response(get_strategy, &range, &history, &deck)
        } else {
            // TODO: Refactor this get_hand() / hole / board thing. Maybe just return an infoset or
            // something. simplify it
            let hand = get_hand(&deck, opponent, history.street);
            let hole = &hand[..2];
            let board = &hand[2..];
            let strategy = get_strategy(hole, board, &history);
            let action = sample_action_from_strategy(&strategy);
            // Update the range given that they made the action
            opp_range.update(&action, |cards| get_strategy(cards, board, &history));
            action
        };
        history.add(&action);
    }
    terminal_utility(&deck, &history, exploiter)
}

fn local_best_response<F>(
    get_strategy: F,
    opp_range: &Range,
    history: &ActionHistory,
    deck: &[Card],
) -> Action 
where F: Fn(&[Card], &[Card], &ActionHistory) -> Strategy
{
    let mut utilities: Strategy = HashMap::new();
    let mut new_range = opp_range.clone();

    let exploiter_hand = get_hand(deck, history.player, history.street);
    let exploiter_hole = &exploiter_hand[..2];
    let board = &exploiter_hand[2..];
    let win_prob = win_probability_rollout(opp_range, exploiter_hole, board);
    let pot = history.pot() as f64;
    let to_call = history.to_call() as f64;

    // Approximate the utility of each potential action (call, pot bet, all in, etc)
    let call_util = win_prob * pot - (1.0 - win_prob) * to_call;
    let mut max_util = call_util;
    let mut best_action = Action {
        action: ActionType::Call,
        amount: history.to_call(),
    };
    let bet_abstraction = vec![BETS.to_vec(); 4]; // Bet abstraction is the same for every street
    for action in history.next_actions(&bet_abstraction) {
        if action.action != ActionType::Bet {
            continue;
        }
        // fold_prob is the probability that the opponent folds after we do this action
        let mut fold_prob = 0.0;
        let mut next_history = history.clone();
        next_history.add(&action);
        // START HERE: If this action is all_in (or ends the hand), then we don't want to go to the next action.

        for (opp_hole, hand_prob) in opp_range.range.clone() {
            // Skip very unlikely hands to avoid wasted computation
            if hand_prob < PROB_CUTOFF {
                continue;
            }

            let opp_strategy = get_strategy(&opp_hole, board, &next_history);
            let fold_strategy: f64 = match opp_strategy.get(&FOLD) {
                Some(s) => *s,
                // If the fold action is not present in the strategy, it's because
                // the player can check so it doesn't make any sense to fold.
                None => 0.0,
            };
            fold_prob += hand_prob * fold_strategy;
            // If the opponent doesn't fold here, we can adjust our beliefs about
            // the probability distribution of their range
            let new_hand_prob = hand_prob * (1.0 - fold_strategy);
            new_range.range.insert(opp_hole.clone(), new_hand_prob);
        }
        new_range.range = normalize(&new_range.range);
        // Calculate the utility of this action assuming we both check/call to
        // showdown after this
        let win_prob = win_probability_rollout(&new_range, exploiter_hole, board);
        let amount = action.amount as f64;

        // The greedy approximation of the expected utility of each possible bet size is:
        // 1) If the bet makes the opponent fold, then you win the pot.
        // 2) If the opponent doesn't fold (calls or re-raises),
        //     a) If you win the hand, you win the current pot + the bet amount
        //     b) If you lose the hand, you lose the bet amount (plus any remaining call amount)
        let util = fold_prob * pot
            + (1.0 - fold_prob)
                * (win_prob * (pot + amount) - (1.0 - win_prob) * (to_call + amount));
        utilities.insert(action.clone(), util);
        if util > max_util {
            max_util = util;
            best_action = action;
        }
    }
    // If the highest utility is negative, it's best to fold. Otherwise return
    // the best action.
    if max_util <= 0.0 && history.is_legal_next_action(&FOLD) {
        FOLD
    } else {
        best_action
    }
}

pub fn win_probability_rollout(
    opp_range: &Range,
    exploiter_hole: &[Card],
    board: &[Card],
) -> f64 {
    let mut deck = card_utils::deck();
    // Remove the blockers (exploiter's hole cards and board cards) from the deck
    deck.retain(|c| !exploiter_hole.contains(c));
    deck.retain(|c| !board.contains(c));
    let board_len = board.len();
    let board: SmallVecHand = board.to_smallvec();
    let exploiter_hole: SmallVecHand = exploiter_hole.to_smallvec();

    let mut wins = 0.0;
    let mut n = 0;
    for i in 0..10 {
        // Sample a random opponent hand from their range
        let opp_hole = opp_range.sample_hand();
        let hand_prob = opp_range.hand_prob(&opp_hole);
        let opp_hole: SmallVecHand = opp_hole.to_smallvec();

        // Remove opp_hole from the deck since they are now blockers as well
        let mut subdeck = deck.clone();
        subdeck.retain(|c| !opp_hole.contains(c));

        // Sample some possible rollouts from the remaining deck
        const N_ROLLOUTS: usize = 10;
        let mut rollouts: Vec<SmallVec<[Card; 5]>> = Vec::with_capacity(N_ROLLOUTS);
        let mut rng = rand::thread_rng();
        for _i in 0..N_ROLLOUTS {
            let rollout: SmallVec<[Card; 5]> = subdeck
                .choose_multiple(&mut rng, 5 - board_len)
                .cloned()
                .collect();
            rollouts.push(rollout);
        }

        for rollout in rollouts {
            let mut full_board: SmallVecHand = board.clone();
            full_board.extend(rollout);
            let mut opp_hand: SmallVecHand = opp_hole.clone();
            opp_hand.extend(full_board.clone());
            let mut exploiter_hand: SmallVecHand = exploiter_hole.clone();
            exploiter_hand.extend(full_board);
            let exploiter_strength = FAST_HAND_TABLE.hand_strength(&exploiter_hand);
            let opp_strength = FAST_HAND_TABLE.hand_strength(&opp_hand);

            if exploiter_strength > opp_strength {
                wins += 1.0;
            } else if exploiter_strength == opp_strength {
                wins += 0.5
            }
            n += 1;
        }
    }
    let win_prob = wins / n as f64;
    win_prob as f64
}
