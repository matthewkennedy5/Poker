// Implementation of Local Best Response calculation for a lower bound on
// exploitability from https://arxiv.org/abs/1612.07547

// I'm using the "fcpa" (fold, call, pot, all-in) action choices from the paper, which is
// way faster and still gives decent results. I'm also having the exploiter
// check/call on the preflop and flop.

// Right now: Sanity check with chump strategies, like always call.

use crate::card_utils;
use crate::card_utils::Card;
use crate::trainer_utils::*;
use bio::stats::combinatorics::combinations;
use itertools::Itertools;
use rand::seq::SliceRandom;
use rayon::iter::IntoParallelIterator;
use rayon::iter::ParallelIterator;
use rayon::prelude::*;
use std::collections::HashMap;

const ITERS: u64 = 1000;
const BETS: [i32; 2] = [1, ALL_IN];

// TODO: Instead of taking in a HashMap<InfoSet, Node> table of strategies, pass
// in a "bot" instance where you give it an infoset and it gives you a strategy or action
pub fn exploitability(nodes: &HashMap<InfoSet, Node>) -> f64 {
    lazy_static::initialize(&HAND_TABLE);
    println!("[INFO] Calculating exploitability...");
    let bar = card_utils::pbar(ITERS);

    // Single thread
    // let mut exploits = Vec::new();
    // for i in 0..ITERS {
    //     let e = play_hand(nodes) / (BIG_BLIND as f64);
    //     exploits.push(e);
    //     bar.inc(1);
    // }

    // Parallel
    let exploits: Vec<f64> = (0..ITERS)
        .into_par_iter()
        .map(|i| {
            let e = play_hand(nodes) / (BIG_BLIND as f64);
            bar.inc(1);
            e
        })
        .collect();

    bar.finish();
    let mean = statistical::mean(&exploits);
    let std = statistical::standard_deviation(&exploits, Some(mean));
    let confidence = 1.96 * std / (ITERS as f64).sqrt();
    println!("Exploitability: {} +/- {} BB/h", mean, confidence);
    mean
}

fn play_hand(nodes: &HashMap<InfoSet, Node>) -> f64 {
    let mut deck = card_utils::deck();
    let mut rng = &mut rand::thread_rng();
    deck.shuffle(&mut rng);
    let exploiter = [DEALER, OPPONENT].choose(&mut rng).unwrap().clone();
    let opponent = 1 - exploiter;
    let mut opp_range = construct_opponent_range(&deck, exploiter);
    let mut history = ActionHistory::new();

    while !history.hand_over() {
        remove_blockers(&mut opp_range, &deck, exploiter, history.street.clone());
        let action = match history.player {
            exploiter => local_best_response(nodes, &opp_range, &history, &deck),
            opponent => Action {
                action: ActionType::Call,
                amount: history.to_call(),
            },
            _ => panic!(),
        };
        // let infoset = InfoSet::from_deck(&deck, &history);
        // TODO: What if the current infoset isn't present in the nodes?
        // Probably just sample uniformly from possible actions, but there
        // should be some sort of warning/error to train for more iterations
        // let node = nodes.get(&infoset).unwrap();
        // let action = sample_action(&node);
        // update_range(&mut opp_range, &node);
        // Chump strategy: always call
        history.add(&action);
    }
    // println!("Exploiter is player {}.", exploiter);
    // println!("Exploiter: {}", card_utils::cards2str(&get_hand(&deck, exploiter, RIVER)));
    // println!("Opponent: {}", card_utils::cards2str(&get_hand(&deck, opponent, RIVER)));
    // println!("{:#?}", history);
    let u = terminal_utility(&deck, history, exploiter);
    // println!("Utility: {}", u);
    // panic!();
    u
}

fn update_range(range: &mut HashMap<Vec<Card>, f64>, node: &Node) {
    unimplemented!();
}

fn construct_opponent_range(deck: &[Card], exploiter: usize) -> HashMap<Vec<Card>, f64> {
    let mut range = HashMap::new();
    let exploiter_hole = get_hand(deck, exploiter, PREFLOP);
    // Remove the exploiter's preflop hand from the range since the opponent
    // can't have the exploiter's cards
    let mut deck = deck.to_vec();
    deck.retain(|c| !exploiter_hole.contains(&c));
    for hand in deck.iter().combinations(2) {
        let hand = card_utils::deepcopy(&hand);
        range.insert(hand, 1.0);
    }
    range = normalize(&range);
    range
}

// When new cards come on the table, the opponent's range cannot contain those
// cards, so we delete them from the range and renormalize.
fn remove_blockers(
    opp_range: &mut HashMap<Vec<Card>, f64>,
    deck: &[Card],
    exploiter: usize,
    street: usize,
) {
    let exploiter_hand = get_hand(deck, exploiter, street);
    let mut new_range = opp_range.clone();
    for hand in opp_range.keys() {
        if exploiter_hand.contains(&hand[0]) || exploiter_hand.contains(&hand[1]) {
            new_range.remove(hand);
        }
    }
    new_range = normalize(&new_range);
    *opp_range = new_range;
}

fn local_best_response(
    nodes: &HashMap<InfoSet, Node>,
    opp_range: &HashMap<Vec<Card>, f64>,
    history: &ActionHistory,
    deck: &[Card],
) -> Action {
    if history.street < TURN {
        // Check/calling the first 2 streets improves LBR's results
        return Action {
            action: ActionType::Call,
            amount: history.to_call(),
        };
    }
    let mut utilities: HashMap<Action, f64> = HashMap::new();
    let mut new_range = opp_range.clone();
    let exploiter_hand = get_hand(deck, history.player, history.street);
    let exploiter_hole = &exploiter_hand[..2];
    let board = &exploiter_hand[2..];
    let win_prob = wp_rollout(opp_range, exploiter_hole, board);
    let pot = history.pot() as f64;
    let to_call = history.to_call() as f64;

    // Approximate the utility of each potential action (call, pot bet, all in, etc)
    let call_util = win_prob * pot - (1.0 - win_prob) * to_call;
    let mut max_util = call_util;
    let mut best_action = Action {
        action: ActionType::Call,
        amount: history.to_call(),
    };
    for action in history.next_actions(BETS.to_vec()) {
        // fold_prob is the probability that the opponent folds after we do this action
        let mut fold_prob = 0.0;
        for (opp_hand, hand_prob) in opp_range {
            let opp_strategy = get_strategy(nodes, history, opp_hand);
            let fold_strategy: f64 = match opp_strategy.get(&FOLD) {
                Some(s) => s.clone(),
                // If the fold action is not present in the strategy, it's because
                // the player can check so it doesn't make any sense to fold.
                None => 0.0,
            };
            fold_prob += hand_prob * fold_strategy;
            // If the opponent doesn't fold here, we can adjust our beliefs about
            // the probability distribution of their range
            let new_hand_prob = hand_prob * (1.0 - fold_strategy);
            new_range.insert(opp_hand.clone(), new_hand_prob);
        }
        new_range = normalize(&new_range);
        // Calculate the utility of this action assuming we both check/call to
        // showdown after this
        let win_prob = wp_rollout(&new_range, exploiter_hole, board);
        let amount = action.amount as f64;
        let util = fold_prob * pot
            + (1.0 - fold_prob)
                * (win_prob * (pot + amount) - (1.0 - win_prob) * (to_call + amount));
        utilities.insert(action.clone(), util);
        if util > max_util {
            max_util = util;
            best_action = action;
        }
    }
    // If the highest utility is negative, it's best to fold. Otherwise return
    // the best action.
    println!("max_util: {}", max_util);
    println!("best_action {}", best_action);
    println!();
    if max_util <= 0.0 {
        FOLD
    } else {
        best_action
    }
}

fn get_strategy(
    nodes: &HashMap<InfoSet, Node>,
    history: &ActionHistory,
    // TODO: also take in the custom opponent hand
    deck: &[Card],
) -> HashMap<Action, f64> {
    // for evaluating the chump strategy for testing
    always_call(history)
    // TODO: change to actually evaluate the strategy at the current node. Need
    // to include both the board and the believed opponent hand
}

fn always_call(history: &ActionHistory) -> HashMap<Action, f64> {
    let mut strategy = HashMap::new();
    let call = Action {
        action: ActionType::Call,
        amount: history.to_call(),
    };
    strategy.insert(call, 1.0);
    strategy
}

fn wp_rollout(opp_range: &HashMap<Vec<Card>, f64>, exploiter_hole: &[Card], board: &[Card]) -> f64 {
    let mut win_prob = 0.0;
    let mut deck = card_utils::deck();
    deck.retain(|c| !exploiter_hole.contains(c));
    deck.retain(|c| !board.contains(c));
    for (opp_hole, hand_prob) in opp_range {
        // We also have to remove the opponent's hole cards from the deck for rollouts
        let mut subdeck = deck.clone();
        subdeck.retain(|c| !opp_hole.contains(c));
        let mut wins = 0.0;
        let mut n = 0.0;
        for rollout in subdeck.iter().combinations(5 - board.len()) {
            let full_board: Vec<Card> = [board, &card_utils::deepcopy(&rollout)].concat();
            let opp_hand = [opp_hole.clone(), full_board.clone()].concat();
            let exploiter_hand = [exploiter_hole.clone(), &full_board].concat();
            let exploiter_strength = HAND_TABLE.hand_strength(&exploiter_hand);
            let opp_strength = HAND_TABLE.hand_strength(&opp_hand);
            if exploiter_strength > opp_strength {
                wins += 1.0;
            } else if exploiter_strength == opp_strength {
                wins += 0.5
            }
            n += 1.0
        }
        win_prob += hand_prob * wins / n;
    }
    win_prob
}
