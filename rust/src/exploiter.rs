// Implementation of Local Best Response calculation for a lower bound on
// exploitability from https://arxiv.org/abs/1612.07547

use crate::bot::Bot;
use crate::card_utils;
use crate::card_utils::*;
use crate::trainer_utils::*;
use crate::ranges::*;
use crate::config::CONFIG;
use rand::seq::SliceRandom;
use rayon::iter::IntoParallelIterator;
use rayon::iter::ParallelIterator;
use std::collections::HashMap;

// const BETS: [f64; 5] = [0.25, 0.75, 1.0, 2.0, ALL_IN];
// TODO: Instead of having the bet abstraction be relative to the pot, have it be log spaced amounts from min to max bet size
const BETS: [f64; 2] = [1.0, ALL_IN];

pub fn exploitability(bot: &Bot, iters: u64) -> f64 {
    println!("[INFO] Calculating exploitability...");
    let bar = card_utils::pbar(iters);

    // Parallel
    let exploits: Vec<f64> = (0..iters)
        .into_par_iter()
        .map(|_i| {
            let e = play_hand(&bot) / (CONFIG.big_blind as f64);
            bar.inc(1);
            e
        })
        .collect();

    bar.finish();
    let mean = statistical::mean(&exploits);
    let std = statistical::standard_deviation(&exploits, Some(mean));
    let confidence = 1.96 * std / (iters as f64).sqrt();
    println!("Exploitability: {} +/- {} BB/h\n", mean, confidence);
    mean
}

fn play_hand(bot: &Bot) -> f64 {
    let mut deck = card_utils::deck();
    let mut rng = &mut rand::thread_rng();
    deck.shuffle(&mut rng);
    let exploiter = [DEALER, OPPONENT].choose(&mut rng).unwrap().clone();
    let opponent = 1 - exploiter;
    // let mut opp_range = construct_opponent_range(&deck, exploiter);
    let mut opp_range: Range = Range::new();
    let exploiter_hole = get_hand(&deck, exploiter, PREFLOP);
    opp_range.remove_blockers(&exploiter_hole);

    let mut history = ActionHistory::new();

    while !history.hand_over() {
        let blockers = get_hand(&deck, exploiter, history.street.clone());
        opp_range.remove_blockers(&blockers);
        let action = if history.player == exploiter {
            let range = opp_range.range.clone();    // TODO: Rewrite local_best_response and win_probability_rollout to input a Range
            local_best_response(bot, &range, &history, &deck)
        } else {
            // TODO: Refactor this get_hand() / hole / board thing. Maybe just return an infoset or 
            // something. simplify it 
            let hand = get_hand(&deck, opponent, history.street);
            let hole = &hand[..2];
            let board = &hand[2..];
            let strategy = bot.get_strategy(hole, board, &history);
            let action = sample_action_from_strategy(&strategy);

            // Closure mapping each possible opponent hand to the strategy policy they would play 
            // with that hand in this spot
            let get_strategy = |cards: &Vec<Card>| -> HashMap<Action, f64> {
                bot.get_strategy(&cards, board, &history)
            };
            // Update the range given that they made the action
            opp_range.update(&action, get_strategy);
            action
        };
        history.add(&action);
    }
    terminal_utility(&deck, history, exploiter)
}

fn local_best_response(
    bot: &Bot,
    opp_range: &HashMap<Vec<Card>, f64>,
    history: &ActionHistory,
    deck: &[Card],
) -> Action {

    let mut utilities: HashMap<Action, f64> = HashMap::new();
    let mut new_range = opp_range.clone();

    let exploiter_hand = get_hand(deck, history.player, history.street);
    let exploiter_hole = &exploiter_hand[..2];
    let board = &exploiter_hand[2..];
    let win_prob = win_probability_rollout(opp_range, exploiter_hole, board);
    let pot = history.pot() as f64;
    let to_call = history.to_call() as f64;

    // Approximate the utility of each potential action (call, pot bet, all in, etc)
    let call_util = win_prob * pot - (1.0 - win_prob) * to_call;
    let mut max_util = call_util;
    let mut best_action = Action {
        action: ActionType::Call,
        amount: history.to_call(),
    };
    let bet_abstraction = vec![BETS.to_vec(); 4]; // Bet abstraction is the same for every street
    for action in history.next_actions(&bet_abstraction) {
        if action.action != ActionType::Bet {
            continue;
        }
        // fold_prob is the probability that the opponent folds after we do this action
        let mut fold_prob = 0.0;
        let mut next_history = history.clone();
        next_history.add(&action);
        for (opp_hole, hand_prob) in opp_range {
            // Skip very unlikely hands to avoid wasted computation
            if hand_prob.clone() < PROB_CUTOFF { 
                continue; 
            }

            let opp_strategy = bot.get_strategy(&opp_hole, &board, &next_history);
            let fold_strategy: f64 = match opp_strategy.get(&FOLD) {
                Some(s) => s.clone(),
                // If the fold action is not present in the strategy, it's because
                // the player can check so it doesn't make any sense to fold.
                None => 0.0,
            };
            fold_prob += hand_prob * fold_strategy;
            // If the opponent doesn't fold here, we can adjust our beliefs about
            // the probability distribution of their range
            let new_hand_prob = hand_prob * (1.0 - fold_strategy);
            new_range.insert(opp_hole.clone(), new_hand_prob);
        }
        new_range = normalize(&new_range);
        // Calculate the utility of this action assuming we both check/call to
        // showdown after this
        let win_prob = win_probability_rollout(&new_range, exploiter_hole, board);
        let amount = action.amount as f64;

        // The greedy approximation of the expected utility of each possible bet size is:
        // 1) If the bet makes the opponent fold, then you win the pot. 
        // 2) If the opponent doesn't fold (calls or re-raises), 
        //     a) If you win the hand, you win the current pot + the bet amount
        //     b) If you lose the hand, you lose the bet amount (plus any remaining call amount)
        let util = fold_prob * pot 
                        + (1.0 - fold_prob) 
                        * (win_prob * (pot + amount) - (1.0 - win_prob) * (to_call + amount));
        utilities.insert(action.clone(), util);
        if util > max_util {
            max_util = util;
            best_action = action;
        }
    }
    // If the highest utility is negative, it's best to fold. Otherwise return
    // the best action.
    if max_util <= 0.0 {
        FOLD
    } else {
        best_action
    }
}

// TODO: Rename this to "win_probability_rollout" or just "rollout"
fn win_probability_rollout(opp_range: &HashMap<Vec<Card>, f64>, exploiter_hole: &[Card], board: &[Card]) -> f64 {
    let mut win_prob = 0.0;
    let mut deck = card_utils::deck();
    // Remove the blockers (exploiter's hole cards and board cards) from the deck
    deck.retain(|c| !exploiter_hole.contains(c));
    deck.retain(|c| !board.contains(c));

    for (opp_hole, hand_prob) in opp_range {
        // Skip very unlikely hands to avoid wasted computation
        if hand_prob.clone() < PROB_CUTOFF {
            continue;
        }

        // Remove opp_hole from the deck since they are now blockers as well
        let mut subdeck = deck.clone();
        subdeck.retain(|c| !opp_hole.contains(c));

        // Sample some possible rollouts from the remaining deck
        let mut rollouts: Vec<Vec<Card>> = Vec::new();
        let mut rng = rand::thread_rng();
        for _i in 0..10 {
            let rollout: Vec<Card> = subdeck.choose_multiple(&mut rng, 5 - board.len()).cloned().collect();
            rollouts.push(rollout);
        }

        let mut wins = 0.0;
        let mut n = 0.0;
        for rollout in rollouts {
            let full_board: Vec<Card> = [board, &rollout].concat();
            let opp_hand = [opp_hole.clone(), full_board.clone()].concat();
            let exploiter_hand = [exploiter_hole.clone(), &full_board].concat();
            let exploiter_strength = FAST_HAND_TABLE.hand_strength(&exploiter_hand);
            let opp_strength = FAST_HAND_TABLE.hand_strength(&opp_hand);

            if exploiter_strength > opp_strength {
                wins += 1.0;
            } else if exploiter_strength == opp_strength {
                wins += 0.5
            }
            n += 1.0
        }
        win_prob += hand_prob * wins / n;
    }
    win_prob
}
