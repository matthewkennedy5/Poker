// Implementation of Local Best Response calculation for a lower bound on
// exploitability from https://arxiv.org/abs/1612.07547

// I'm using the "fcpa" (fold, call, pot, all-in) action choices from the paper, which is
// way faster and still gives decent results. I'm also having the exploiter
// check/call on the preflop and flop.

use crate::card_utils;
use crate::card_utils::Card;
use crate::trainer_utils::*;
use itertools::Itertools;
use rand::seq::SliceRandom;
use rayon::iter::IntoParallelIterator;
use rayon::iter::ParallelIterator;
use std::collections::HashMap;

const ITERS: u64 = 10_000;
const BETS: [f64; 2] = [1.0, ALL_IN];

// TODO: Instead of taking in a HashMap<InfoSet, Node> table of strategies, pass
// in a "bot" instance where you give it an infoset and it gives you a strategy or action
pub fn exploitability(nodes: &HashMap<InfoSet, Node>) -> f64 {
    lazy_static::initialize(&HAND_TABLE);
    lazy_static::initialize(&ABSTRACTION);
    println!("[INFO] Calculating exploitability...");
    let bar = card_utils::pbar(ITERS);

    // Single thread
    // let mut exploits = Vec::new();
    // for i in 0..ITERS {
    //     let e = play_hand(nodes) / (BIG_BLIND as f64);
    //     exploits.push(e);
    //     bar.inc(1);
    // }

    // Parallel
    let exploits: Vec<f64> = (0..ITERS)
        .into_par_iter()
        .map(|i| {
            let e = play_hand(nodes) / (BIG_BLIND as f64);
            bar.inc(1);
            e
        })
        .collect();

    bar.finish();
    let mean = statistical::mean(&exploits);
    let std = statistical::standard_deviation(&exploits, Some(mean));
    let confidence = 1.96 * std / (ITERS as f64).sqrt();
    println!("Exploitability: {} +/- {} BB/h\n", mean, confidence);
    mean
}

fn play_hand(nodes: &HashMap<InfoSet, Node>) -> f64 {
    let mut deck = card_utils::deck();
    let mut rng = &mut rand::thread_rng();
    deck.shuffle(&mut rng);
    let exploiter = [DEALER, OPPONENT].choose(&mut rng).unwrap().clone();
    let opponent = 1 - exploiter;
    let mut opp_range = construct_opponent_range(&deck, exploiter);
    let mut history = ActionHistory::new();

    while !history.hand_over() {
        remove_blockers(&mut opp_range, &deck, exploiter, history.street.clone());
        let action = if history.player == exploiter {
            local_best_response(nodes, &opp_range, &history, &deck)
        } else {
            let hand = get_hand(&deck, opponent, history.street);
            let board = &hand[2..];
            let strategy = get_strategy(nodes, &history, &hand);
            let action = sample_action_from_strategy(&strategy);
            let old_range = opp_range.clone();
            update_range(&mut opp_range, &action, nodes, &history, board);
            action
        };
        history.add(&action);
    }
    terminal_utility(&deck, history, exploiter)
}

// Updates the opponent's range given the fact that they made a certain action
// at a certain infoset. action is not included in history.
fn update_range(
    range: &mut HashMap<Vec<Card>, f64>,
    action: &Action,
    nodes: &HashMap<InfoSet, Node>,
    history: &ActionHistory,
    board: &[Card],
) {
    let mut new_range = range.clone();
    for (hole, prob) in range.clone() {
        let hand = [hole.clone(), board.to_vec()].concat();
        let strategy = get_strategy(nodes, history, &hand);
        // If the action is not found in the strategy, it has a probability of 0.
        let new_prob = match strategy.get(action) {
            Some(p) => prob * p,
            None => 0.0,
        };
        new_range.insert(hole.clone(), new_prob);
    }
    new_range = normalize(&new_range);
    *range = new_range;
}

fn construct_opponent_range(deck: &[Card], exploiter: usize) -> HashMap<Vec<Card>, f64> {
    let mut range = HashMap::new();
    let exploiter_hole = get_hand(deck, exploiter, PREFLOP);
    // Remove the exploiter's preflop hand from the range since the opponent
    // can't have the exploiter's cards
    let mut deck = deck.to_vec();
    deck.retain(|c| !exploiter_hole.contains(&c));
    for hand in deck.iter().combinations(2) {
        let hand = card_utils::deepcopy(&hand);
        range.insert(hand, 1.0);
    }
    range = normalize(&range);
    range
}

// When new cards come on the table, the opponent's range cannot contain those
// cards, so we delete them from the range and renormalize.
fn remove_blockers(
    opp_range: &mut HashMap<Vec<Card>, f64>,
    deck: &[Card],
    exploiter: usize,
    street: usize,
) {
    let exploiter_hand = get_hand(deck, exploiter, street);
    let mut new_range = opp_range.clone();
    for hand in opp_range.keys() {
        if exploiter_hand.contains(&hand[0]) || exploiter_hand.contains(&hand[1]) {
            new_range.remove(hand);
        }
    }
    new_range = normalize(&new_range);
    *opp_range = new_range;
}

fn local_best_response(
    nodes: &HashMap<InfoSet, Node>,
    opp_range: &HashMap<Vec<Card>, f64>,
    history: &ActionHistory,
    deck: &[Card],
) -> Action {
    if history.street < TURN {
        // Check/calling the first 2 streets improves LBR's results
        return Action {
            action: ActionType::Call,
            amount: history.to_call(),
        };
    }
    let mut utilities: HashMap<Action, f64> = HashMap::new();
    let mut new_range = opp_range.clone();
    let exploiter_hand = get_hand(deck, history.player, history.street);
    let exploiter_hole = &exploiter_hand[..2];
    let board = &exploiter_hand[2..];
    let win_prob = wp_rollout(opp_range, exploiter_hole, board);
    let pot = history.pot() as f64;
    let to_call = history.to_call() as f64;

    // Approximate the utility of each potential action (call, pot bet, all in, etc)
    let call_util = win_prob * pot - (1.0 - win_prob) * to_call;
    let mut max_util = call_util;
    let mut best_action = Action {
        action: ActionType::Call,
        amount: history.to_call(),
    };
    let bet_abstraction = vec![BETS.to_vec(); 4]; // Bet abstraction is the same for every stree street
    for action in history.next_actions(&bet_abstraction) {
        if action.action != ActionType::Bet {
            continue;
        }
        // fold_prob is the probability that the opponent folds after we do this action
        let mut fold_prob = 0.0;
        let mut next_history = history.clone();
        next_history.add(&action);
        for (opp_hole, hand_prob) in opp_range {
            let opp_hand = [opp_hole, board].concat();
            let opp_strategy = get_strategy(nodes, &next_history, &opp_hand);
            let fold_strategy: f64 = match opp_strategy.get(&FOLD) {
                Some(s) => s.clone(),
                // If the fold action is not present in the strategy, it's because
                // the player can check so it doesn't make any sense to fold.
                None => 0.0,
            };
            fold_prob += hand_prob * fold_strategy;
            // If the opponent doesn't fold here, we can adjust our beliefs about
            // the probability distribution of their range
            let new_hand_prob = hand_prob * (1.0 - fold_strategy);
            new_range.insert(opp_hole.clone(), new_hand_prob);
        }
        new_range = normalize(&new_range);
        // Calculate the utility of this action assuming we both check/call to
        // showdown after this
        let win_prob = wp_rollout(&new_range, exploiter_hole, board);
        let amount = action.amount as f64;
        let util = fold_prob * pot
            + (1.0 - fold_prob)
                * (win_prob * (pot + amount) - (1.0 - win_prob) * (to_call + amount));
        utilities.insert(action.clone(), util);
        if util > max_util {
            max_util = util;
            best_action = action;
        }
    }
    // If the highest utility is negative, it's best to fold. Otherwise return
    // the best action.
    if max_util <= 0.0 {
        FOLD
    } else {
        best_action
    }
}

fn get_strategy(
    nodes: &HashMap<InfoSet, Node>,
    history: &ActionHistory,
    hand: &[Card],
) -> HashMap<Action, f64> {
    let infoset = InfoSet::from_hand(hand, history);
    let node = match nodes.get(&infoset) {
        Some(n) => n.clone(),
        None => {
            // If the node is not found, that means the trainer never reached that
            // node in Monte Carlo sampling of the game tree. In this case the
            // strategy we return will be a uniform distribution over the possible
            // actions.
            // println!("Game node not traversed");
            Node::new(&infoset)
        }
    };
    let strategy = node.cumulative_strategy();
    strategy
}

// Chump strategy I made up, which calls unless the player has a spade and it's the
// turn or later, in which case it goes all in. I expect this strategy to be more
// exploitable than always call, and it will be a good test of update_range().
fn spade_all_in(history: &ActionHistory, hand: &[Card]) -> HashMap<Action, f64> {
    let mut strategy = HashMap::new();
    let hole = &hand[..2];
    let spade =
        // hole[0].suit == card_utils::SPADES as u8 || hole[1].suit == card_utils::SPADES as u8;
        hole[0].rank < 6 || hole[1].rank < 6;
    if history.street >= TURN && spade {
        let all_in = Action {
            action: ActionType::Bet,
            amount: history.stack_sizes()[history.player],
        };
        strategy.insert(all_in, 1.0);
        return strategy;
    } else {
        return always_call(history);
    }
}

// Chump strategy where the opponent tells the exploiter its cards with its bet size.
// Always bets 10x sum of its card values (15 * suit + rank) (if legal, otherwise
// check/call). This should be
// extrememly exploitable because the exploiter should have a very good idea of
// what cards the opponent has.
fn tell_cards_chump(history: &ActionHistory, hand: &[Card]) -> HashMap<Action, f64> {
    let card1 = &hand[0];
    let card2 = &hand[1];
    let bet_size: i32 =
        history.min_bet() + 10 * (15 * (card1.suit + card2.suit) + card1.rank + card2.rank) as i32;
    if history.is_bet_legal(bet_size) {
        let mut strategy = HashMap::new();
        let bet = Action {
            action: ActionType::Bet,
            amount: bet_size,
        };
        strategy.insert(bet, 1.0);
        strategy
    } else {
        always_call(history)
    }
}

pub fn always_call(history: &ActionHistory) -> HashMap<Action, f64> {
    let mut strategy = HashMap::new();
    let call = Action {
        action: ActionType::Call,
        amount: history.to_call(),
    };
    strategy.insert(call, 1.0);
    strategy
}

fn wp_rollout(opp_range: &HashMap<Vec<Card>, f64>, exploiter_hole: &[Card], board: &[Card]) -> f64 {
    let mut win_prob = 0.0;
    let mut deck = card_utils::deck();
    deck.retain(|c| !exploiter_hole.contains(c));
    deck.retain(|c| !board.contains(c));
    for (opp_hole, hand_prob) in opp_range {
        // We also have to remove the opponent's hole cards from the deck for rollouts
        let mut subdeck = deck.clone();
        subdeck.retain(|c| !opp_hole.contains(c));
        let mut wins = 0.0;
        let mut n = 0.0;
        for rollout in subdeck.iter().combinations(5 - board.len()) {
            let full_board: Vec<Card> = [board, &card_utils::deepcopy(&rollout)].concat();
            let opp_hand = [opp_hole.clone(), full_board.clone()].concat();
            let exploiter_hand = [exploiter_hole.clone(), &full_board].concat();
            let exploiter_strength = HAND_TABLE.hand_strength(&exploiter_hand);
            let opp_strength = HAND_TABLE.hand_strength(&opp_hand);
            if exploiter_strength > opp_strength {
                wins += 1.0;
            } else if exploiter_strength == opp_strength {
                wins += 0.5
            }
            n += 1.0
        }
        win_prob += hand_prob * wins / n;
    }
    win_prob
}
