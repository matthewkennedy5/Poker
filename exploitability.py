# Implementation of Local Best Response calculation for a lower bound on
# exploitability from https://arxiv.org/abs/1612.07547

# I'm using the "fcpa" (fold, call, pot, all-in) action choices from the paper, which is
# way faster and still gives decent results. I'm also having the exploiter
# check/call on the preflop and flop.

from itertools import combinations, product
import numpy as np
from tqdm import trange
from texas_utils import get_deck
from trainer_utils import normalize
from texas_hands import TexasHand
from hand_table import HandTable
from texas_utils import pbar_map

ITERS = 2000
ROLLOUT_SAMPLES = 50
BIG_BLIND = 100
STACK_SIZE = 200 * BIG_BLIND
ACTIONS = 'fold', 'call', 'pot', 'all-in'
HAND_TABLE = HandTable()


def check_call(street, stacks):
    if street == "preflop" and sum(stacks.values()) == 2*STACK_SIZE:
        return {"action": "bet", "amount": BIG_BLIND}
    elif stacks["opponent"] == stacks["exploiter"]:
        return {"action": "check", "amount": 0}
    else:
        return {"action": "call", "amount": abs(stacks["opponent"] - stacks["exploiter"])}


def cpu_action(street, stacks):
    return check_call(street, stacks)


def rollouts(hole1, hole2, board, street):
    deck = get_deck()
    deck.remove(hole1[0])
    deck.remove(hole1[1])
    deck.remove(hole2[0])
    deck.remove(hole2[1])
    if street == 'preflop':
        n_rollouts = 5
    elif street == 'flop':
        n_rollouts = 2
    elif street == 'turn':
        n_rollouts = 1
    elif street == 'river':
        return [board]

    # Remove board cards already in deck
    n_board = 5 - n_rollouts
    for i in range(n_board):
        deck.remove(board[i])

    rollouts = [board[:n_board] + list(rollout) for rollout in combinations(deck, n_rollouts)]
    return rollouts


def win_probability(exploiter_hole, opp_range, board, street):
    win_prob = 0
    opp_hands = list(opp_range.keys())
    np.random.shuffle(opp_hands)
    for opp_hole in opp_hands[:ROLLOUT_SAMPLES]:
        wins = 0
        n = 0
        for rollout in rollouts(exploiter_hole, list(opp_hole), board, street):
            exploiter_hand = exploiter_hole + rollout
            opp_hand = list(opp_hole) + rollout
            exploiter_strength = HAND_TABLE[exploiter_hand]
            opp_strength = HAND_TABLE[opp_hand]
            if exploiter_strength > opp_strength:
                wins += 1
            elif exploiter_strength == opp_strength:
                wins += 0.5
            n += 1

        # win_prob += opp_range[opp_hole] * wins/n
        win_prob += wins / n / ROLLOUT_SAMPLES

    return win_prob


def chump_strategy(opp_hand, board, action):
    # TODO: Only legal actions are allowed
    if action == 'call':
        return 1
    else:
        return 0


def get_amount(action, pot, stacks):
    if action == 'pot':
        return pot
    elif action == 'all-in':
        return stacks["exploiter"]
    elif action == 'fold':
        return 0
    elif action == 'call':
        return abs(stacks["exploiter"] - stacks["opponent"])


def legal_actions(stacks):
    pot = 2*STACK_SIZE - stacks["exploiter"] - stacks["opponent"]
    if stacks["exploiter"] > pot:
        return ('pot', 'all-in')
    elif stacks['exploiter'] > 0:
        return ('all-in',)
    else:
        return ()


def local_best_response(strategy, opp_range, history, board, exploiter_hole, street, stacks):
    if street == "preflop" or street == "flop":
        return check_call(street, stacks)

    utilities = {action: 0 for action in ACTIONS}
    new_range = opp_range.copy()
    win_prob = win_probability(exploiter_hole, opp_range, board, street)
    to_call = stacks["exploiter"] - stacks["opponent"]
    pot = 2*STACK_SIZE - stacks["exploiter"] - stacks["opponent"]
    utilities['call'] = win_prob * pot - (1 - win_prob) * to_call
    for action in legal_actions(stacks):
        fold_prob = 0
        for opp_hand in opp_range:
            opp_strategy = chump_strategy(opp_hand, board, 'fold')
            fold_prob += opp_range[opp_hand] * opp_strategy
            new_range[opp_hand] = opp_range[opp_hand] * (1 - opp_strategy)

        normalize(new_range)
        win_prob = win_probability(exploiter_hole, new_range, board, street)
        amount = get_amount(action, pot, stacks)
        utilities[action] = fold_prob * pot + (1 - fold_prob) * (win_prob * (pot + amount) - (1 - win_prob) * (to_call + amount))

    if max(utilities.values()) > 0:
        action = max(utilities.keys(), key=lambda a: utilities[a])
        return {"action": action, "amount": get_amount(action, pot, stacks)}
    else:
        return {"action": "fold", "amount": 0}



def update_range(opp_range, strategy):
    return opp_range    # Since the opponent is always calling here, we get no new range information


def whose_turn(street, dealer):
    if street == "preflop":
        return dealer
    elif dealer == "exploiter":
        return "opponent"
    else:
        return "exploiter"


def remove_blockers(opp_range, board, street):
    if street == "preflop":
        n_blockers = 0
    elif street == "flop":
        n_blockers = 3
    elif street == "turn":
        n_blockers = 4
    elif street == "river":
        n_blockers = 5
    blockers = board[:n_blockers]
    new_range = opp_range.copy()
    for blocker in blockers:
        for hand in opp_range:
            if blocker in hand and hand in new_range:
                del new_range[hand]
    return new_range


# TODO: Consider when the opponent is the dealer
def play_hand(strategy):
    deck = get_deck()
    np.random.shuffle(deck)
    exploiter_hole = deck[:2]
    opponent_hole = deck[2:4]
    board = deck[4:9]

    dealer = "exploiter"
    if np.random.random() > 0.5:
        dealer = "opponent"


    deck.remove(exploiter_hole[0])
    deck.remove(exploiter_hole[1])
    opp_range = {frozenset((card1, card2)): 1 for (card1, card2) in combinations(deck, 2)}
    normalize(opp_range)

    stacks = {"exploiter": STACK_SIZE, "opponent": STACK_SIZE}
    streets = 'preflop', 'flop', 'turn', 'river'
    history = {street: [] for street in streets}

    for street in 'preflop', 'flop', 'turn', 'river':
        turn = whose_turn(street, dealer)
        opp_range = remove_blockers(opp_range, board, street)
        while True:
            if turn == "exploiter":
                action = local_best_response(strategy, opp_range, history, board, exploiter_hole, street, stacks)
                stacks["exploiter"] -= action["amount"]
                turn = "opponent"
                if action["action"] == "fold":
                    return stacks["exploiter"] - STACK_SIZE
            else:
                action = cpu_action(street, stacks)
                opp_range = update_range(opp_range, strategy)
                stacks["opponent"] -= action["amount"]
                turn = "exploiter"
                if action["action"] == "fold":
                    return STACK_SIZE - stacks["opponent"]
            history[street].append(action)
            if len(history[street]) >= 2 and stacks["exploiter"] == stacks["opponent"]:
                break

    # Showdown
    exploiter_hand = TexasHand(exploiter_hole + board)
    opponent_hand = TexasHand(opponent_hole + board)
    half_pot = STACK_SIZE - stacks["exploiter"]
    if exploiter_hand > opponent_hand:
        return half_pot
    elif opponent_hand > exploiter_hand:
        return -half_pot
    else:
        return 0    # split pot    # TODO: Revise these for the case of unequal pot contribution


def plot(distribution):
    from matplotlib import pyplot as plt
    plt.figure()
    plt.hist(distribution, bins=50)
    plt.show()


def exploit(strategy):
    exploitability = pbar_map(play_hand, [{} for i in range(ITERS)])
    # exploitability = np.zeros(ITERS)
    # for i in trange(ITERS):
    #     exploitability[i] = play_hand(strategy) / BIG_BLIND
    #     mean = np.mean(exploitability[:i])
    #     std = np.std(exploitability[:i])
    #     confidence = 1.96 * std / np.sqrt(i+1)
    #     print("{} +/- {} BB/h".format(mean, confidence))

    exploitability = np.array(exploitability) / BIG_BLIND
    mean = np.mean(exploitability)
    std = np.std(exploitability)
    confidence = 1.96 * std / np.sqrt(ITERS)
    print("{} +/- {} BB/h".format(mean, confidence))
    plot(exploitability)


if __name__ == '__main__':
    strategy = {}
    exploit(strategy)
